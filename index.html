<!DOCTYPE html>
<!--
====================================
File: git-gource.html
Version: V1.1 (2026-02-01)
Description: Gource-style Git repository visualization
             Free-form tree structure with directories as branches, files as leaves
             Developer avatars moving on the tree with glow effects

Features:
- Load local git log file (no API limits)
- Free-form tree layout: root at center, branches expand naturally
- Developer avatars with glow effects moving to edited files
- Timeline playback with commit history (skips empty commits)
- File type coloring (JS=yellow, HTML=orange, CSS=blue, etc.)
- Camera controls (zoom, pan, rotate) with limits
- Hover tooltips showing file paths and contributor names
- Laser beams from contributors to files on edit
- Contributor sprites maintain fixed viewport size
- Line change statistics: total +/- lines in stats panel
- Per-commit and per-file +/- line counts in commit panel

Usage:
1. Run the provided git command in your repository
2. Drag & drop the generated log file, or click to select
3. Use timeline controls to play/pause animation
4. Mouse: left-drag rotate, scroll zoom, right-drag pan
5. Hover over files or contributors to see names

Dependencies:
- Three.js (0.160.0) - 3D rendering
- OrbitControls - Camera control

Change Log:
- 2026-02-01: V1.1 - Added line change statistics (total +/- lines in stats panel,
              per-commit and per-file +/- in commit panel)
- 2026-01-09: V1 - Full Gource-style visualization with force-directed tree layout,
              contributor avatars, laser beams, path compression, smart positioning

========== TREE GENERATION STRATEGY ==========

1. Path Compression:
   - Folders with only 1 child folder and 0 direct files are skipped
   - Files cluster on the first "effective parent" (branch point or folder with files)
   - Example: /a/b/c/file.js ‚Üí if a,b have single children, file clusters under c
   - Tooltip still shows full path, but tree structure is simplified

2. Force-Directed Layout:
   - Root node fixed at origin (0,0,0)
   - Folder nodes use spring forces (restLength = FOLDER_DISTANCE = 75)
   - Repulsion between all folder pairs: F = 4000 / dist¬≤
   - Outward expansion: folders pushed away from root with 1/dist gradient
   - Alpha decay: 0.98 per frame, minimum 10% (simulation never fully stops)
   - Damping: 0.7 (velocity preserved each frame)

3. File Clustering (Gravity Trap):
   - Files attract toward parent center: F = dist * 0.05
   - Files repel siblings: F = 20 / dist¬≤ (min dist = 3)
   - Hard boundary at FILE_CLUSTER_RADIUS * 2.5
   - Single file centers directly on parent (no physics)

4. Rendering:
   - Folder nodes are invisible (only files rendered as colored dots)
   - Lines only drawn when folder has visible descendant files
   - File colors based on extension (JS=yellow, TS=blue, etc.)

========== CONTRIBUTOR MOVEMENT STRATEGY ==========

1. Spawn Position:
   - First appearance: outer side of first touched file
   - Distance from file: ~8% of camera view (spawnRadius = cameraZ * 0.08)
   - Direction: radially outward from root through file position

2. Target Position (per commit):
   - Multi-file commits: use MEDIAN of file positions (resists outliers)
   - Target = median center + outward direction * spawnRadius + random wander
   - Wander distance: 30% of spawnRadius
   - Only moves if new target > 50% of spawnRadius from current target (reduces jitter)

3. Movement:
   - Deceleration: lerp with factor = 1 - 0.02^(deltaTime * playSpeed)
   - Max speed cap: cameraZ * 0.3 * deltaTime (relative to view, prevents flash)
   - Movement speed independent of playback speed multiplier

4. Visibility:
   - Opacity = 1 when active
   - Fade out after 3s / playSpeed of inactivity
   - Fade speed = 0.4 * playSpeed
   - Sprite size fixed relative to viewport (scales with camera distance)

5. Laser Beams:
   - Triangle geometry from contributor to each touched file
   - Duration: 500ms, opacity fades from 0.25 to 0
   - Delete lasers: red tint (0xff4444), fixed target position

Camera System:
  - Auto-follows bounding box of visible nodes
  - Zoom limits: minDistance=150, maxDistance=5000
  - Smooth movement with 5% lerp per frame
====================================
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="icon" href="favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Gource - Repository Visualization Tool</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="Visualize your Git repository history with Gource-style 3D animation. See developers, files, and commits as an interactive tree with Three.js rendering.">
    <meta name="keywords"
        content="git visualization, gource, repository history, git log viewer, 3D git, commit animation, three.js">
    <meta name="author" content="ibarapascal">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://pages.mkhr.co.jp/git-gource.html">

    <!-- Open Graph -->
    <meta property="og:title" content="Git Gource - Repository Visualization Tool">
    <meta property="og:description"
        content="Visualize your Git repository history with Gource-style 3D animation. Interactive tree view of commits and contributors.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pages.mkhr.co.jp/git-gource.html">
    <meta property="og:site_name" content="Ê†™Âºè‰ºöÁ§æÂπïÂºµÈñãÁô∫ | Makuhari Development Corporation">

    <style>
        :root {
            --bg-primary: #0a0a12;
            --bg-secondary: #12121f;
            --bg-tertiary: #1a1a2e;
            --border-color: #2a2a4a;
            --text-primary: #e8e8f0;
            --text-secondary: #8888aa;
            --accent-primary: #00d4ff;
            --accent-secondary: #7b2dff;
            --accent-success: #00ff88;
            --accent-danger: #ff3366;
            --accent-warning: #ffaa00;

            /* Gource Theme Variables */
            --theme-bg: #0a0a12;
            --theme-text: #e8e8f0;
            --theme-dir: #00d4ff;

            /* UI Overlay */
            --glass-bg: rgba(20, 20, 35, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            background: var(--theme-bg);
            color: var(--theme-text);
            overflow: hidden;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            touch-action: none;
            /* Prevent browser handling of touch/trackpad gestures */
        }

        #canvas-container canvas {
            touch-action: none;
        }

        /* Intro Screen */
        .intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 900;
            padding: 20px;
        }

        .intro-screen.hidden {
            display: none;
        }

        .intro-title {
            font-size: 48px;
            font-weight: 300;
            color: var(--accent-primary);
            margin-bottom: 16px;
            letter-spacing: 4px;
        }

        .intro-subtitle {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        /* Drop Zone */
        .drop-zone {
            width: 100%;
            max-width: 600px;
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--bg-secondary);
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: var(--accent-primary);
            background: rgba(0, 212, 255, 0.05);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.6;
        }

        .drop-zone-text {
            font-size: 16px;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .drop-zone-hint {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Command Box */
        .command-box {
            width: 100%;
            max-width: 600px;
            margin-top: 32px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
            text-align: left;
        }

        .command-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .command-text {
            font-size: 13px;
            color: var(--accent-success);
            background: var(--bg-primary);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: nowrap;
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .command-text:hover {
            border-color: var(--accent-primary);
        }

        .command-hint {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 8px;
            opacity: 0.7;
        }

        .copy-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--accent-success);
            color: #000;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .copy-feedback.show {
            opacity: 1;
        }

        /* Hidden file input */
        #file-input {
            display: none;
        }

        /* Reference link */
        .reference {
            margin-top: 32px;
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.6;
        }

        .reference a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .reference a:hover {
            text-decoration: underline;
        }

        .powered-by {
            font-size: 10px;
            margin-top: 4px;
            opacity: 0.6;
        }

        .powered-by a {
            color: inherit;
            text-decoration: none;
        }

        .powered-by a:hover {
            text-decoration: underline;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.3s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 20px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .progress-bar {
            width: 240px;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            margin-top: 16px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            width: 0%;
            transition: width 0.2s;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 20px;
            z-index: 1000;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .timeline-container {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            background: var(--accent-primary);
            border: none;
            border-radius: 50%;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .play-btn:hover {
            background: #00e5ff;
            transform: scale(1.1);
        }

        .timeline-slider {
            width: 400px;
            -webkit-appearance: none;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent-primary);
        }

        .timeline-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            min-width: 120px;
        }

        .timeline-date {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .timeline-commit {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border-color);
        }

        .speed-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .speed-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #000;
        }

        /* Stats Panel */
        .stats-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            z-index: 1000;
            display: none;
            min-width: 180px;
        }

        .stats-title {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .stat-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent-primary);
        }

        /* Current Commit Panel */
        .commit-panel {
            position: fixed;
            top: 16px;
            right: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            z-index: 1000;
            display: none;
            max-width: 300px;
        }

        .commit-author {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .author-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .author-name {
            font-size: 14px;
            font-weight: 500;
        }

        .commit-message {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .commit-files {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .file-change {
            font-size: 11px;
            padding: 3px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .file-change.added::before {
            content: '+';
            color: var(--accent-success);
            font-weight: bold;
        }

        .file-change.deleted::before {
            content: '-';
            color: var(--accent-danger);
            font-weight: bold;
        }

        .file-change.modified::before {
            content: '~';
            color: var(--accent-warning);
            font-weight: bold;
        }

        .file-change .line-stats {
            margin-left: auto;
            font-size: 10px;
            white-space: nowrap;
        }

        .file-change .line-stats .added {
            color: var(--accent-success);
        }

        .file-change .line-stats .deleted {
            color: var(--accent-danger);
        }

        .commit-line-summary {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
            font-size: 12px;
        }

        .commit-line-summary .added {
            color: var(--accent-success);
        }

        .commit-line-summary .deleted {
            color: var(--accent-danger);
        }

        /* Reset Button */
        .reset-btn {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 16px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            z-index: 1000;
            display: none;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(10, 10, 18, 0.95);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 3000;
            pointer-events: none;
            display: none;
            max-width: 300px;
            word-break: break-all;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .tooltip.visible {
            display: block;
        }

        /* Error Toast */
        .error-toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-danger);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 2000;
            display: none;
            max-width: 400px;
            text-align: center;
        }

        /* Mobile responsive */
        @media (max-width: 800px) {
            .intro-title {
                font-size: 32px;
            }

            .timeline-slider {
                width: 200px;
            }

            .command-text {
                font-size: 11px;
            }

            .stats-panel,
            .commit-panel {
                max-width: calc(50% - 24px);
            }
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            z-index: 2000;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .settings-modal.visible {
            display: block;
        }

        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
            backdrop-filter: blur(2px);
        }

        .settings-overlay.visible {
            display: block;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px;
        }

        .settings-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .close-btn:hover {
            color: var(--text-primary);
        }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-picker-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            background: var(--bg-tertiary);
            padding: 8px 12px;
            border-radius: 8px;
        }

        .color-picker-label {
            font-size: 14px;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            background: none;
            cursor: pointer;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid var(--border-color);
            border-radius: 50%;
        }

        .settings-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            margin-left: 8px;
        }

        .settings-btn:hover {
            background: var(--accent-primary);
            color: #000;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 8px;
        }

        .preset-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .preset-btn.active {
            background: var(--accent-primary);
            color: #000;
            border-color: var(--accent-primary);
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="tooltip" class="tooltip"></div>

    <!-- Intro Screen -->
    <div id="intro-screen" class="intro-screen">
        <div class="intro-title">GIT GOURCE</div>
        <div class="intro-subtitle">Visualize your repository's evolution</div>

        <div class="drop-zone" id="drop-zone">
            <div class="drop-zone-icon">üìÅ</div>
            <div class="drop-zone-text">Drop git log file here or click to select</div>
            <div class="drop-zone-hint">Supports .txt or .log files</div>
        </div>

        <div class="command-box">
            <div class="command-label">Step 1: Run this command in your repository</div>
            <div class="command-text" id="command-text">git log --reverse --numstat
                --pretty=format:"COMMIT|%H|%an|%ae|%aI|%s" > git-history.txt</div>
            <div class="command-hint">Click to copy ‚Ä¢ Then drag the generated file above</div>
        </div>

        <input type="file" id="file-input" accept=".txt,.log">

        <div class="reference">
            <div>Inspired by <a href="https://github.com/acaudwell/Gource" target="_blank" rel="noopener">Gource</a>
            </div>
            <div class="powered-by">Powered by Makuhari K.K. <a href="https://github.com/ibarapascal"
                    target="_blank">@ibarapascal</a></div>
        </div>
    </div>

    <!-- Copy Feedback -->
    <div class="copy-feedback" id="copy-feedback">Copied to clipboard!</div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">Parsing git history...</div>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill"></div>
        </div>
    </div>

    <!-- Stats Panel -->
    <div id="stats-panel" class="stats-panel">
        <div class="stats-title">Statistics</div>
        <div class="stat-row">
            <span class="stat-label">Commits</span>
            <span class="stat-value" id="stat-commits">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Files</span>
            <span class="stat-value" id="stat-files">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Authors</span>
            <span class="stat-value" id="stat-authors">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Lines +</span>
            <span class="stat-value" id="stat-lines-added" style="color: var(--accent-success)">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Lines ‚àí</span>
            <span class="stat-value" id="stat-lines-deleted" style="color: var(--accent-danger)">0</span>
        </div>
    </div>

    <!-- Current Commit Panel -->
    <div id="commit-panel" class="commit-panel">
        <div class="commit-author">
            <div class="author-avatar" id="author-avatar">?</div>
            <div class="author-name" id="author-name">-</div>
        </div>
        <div class="commit-message" id="commit-message">-</div>
        <div class="commit-files" id="commit-files"></div>
    </div>

    <!-- Control Panel -->
    <div id="control-panel" class="control-panel">
        <div class="timeline-container">
            <button class="play-btn" id="play-btn">‚ñ∂</button>
            <input type="range" class="timeline-slider" id="timeline-slider" min="0" max="100" value="0">
            <div class="timeline-info">
                <div class="timeline-date" id="timeline-date">-</div>
                <div class="timeline-commit" id="timeline-commit">Commit 0 / 0</div>
            </div>
            <button class="settings-btn" id="settings-btn" title="Settings">‚öô</button>
            <div class="speed-control">
                <button class="speed-btn active" data-speed="1">1x</button>
                <button class="speed-btn" data-speed="2">2x</button>
                <button class="speed-btn" data-speed="4">4x</button>
                <button class="speed-btn" data-speed="8">8x</button>
                <button class="speed-btn" data-speed="16">16x</button>
            </div>
        </div>
    </div>

    <!-- Reset Button -->
    <button class="reset-btn" id="reset-btn">‚Üê Load another file</button>

    <!-- Error Toast -->
    <div id="error-toast" class="error-toast"></div>

    <!-- Settings Modal -->
    <div class="settings-overlay" id="settings-overlay"></div>
    <div class="settings-modal" id="settings-modal">
        <div class="settings-header">
            <div class="settings-title">Settings</div>
            <button class="close-btn" id="close-settings">√ó</button>
        </div>

        <div class="settings-group">
            <label class="settings-label">Colors</label>
            <div class="color-picker-row">
                <span class="color-picker-label">Background</span>
                <input type="color" id="bg-color-picker" value="#0a0a12">
            </div>
            <div class="color-picker-row">
                <span class="color-picker-label">Directories</span>
                <input type="color" id="dir-color-picker" value="#00d4ff">
            </div>
            <div class="color-picker-row">
                <span class="color-picker-label">Text</span>
                <input type="color" id="text-color-picker" value="#e8e8f0">
            </div>
            <div class="settings-group-divider" style="margin: 15px 0; border-top: 1px solid var(--border-color);">
            </div>
            <div class="color-picker-row">
                <span class="color-picker-label">Extension Colors</span>
                <input type="checkbox" id="ext-colors-toggle" checked
                    style="width: 20px; height: 20px; cursor: pointer;">
            </div>
        </div>

        <div class="settings-group">
            <label class="settings-label">Effects</label>
            <div class="color-picker-row">
                <span class="color-picker-label">Bloom</span>
                <input type="checkbox" id="bloom-toggle" checked style="width: 20px; height: 20px; cursor: pointer;">
            </div>
            <div class="color-picker-row">
                <span class="color-picker-label">Bloom Intensity</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="range" id="bloom-slider" min="0" max="3" step="0.1" value="1.5" style="width: 80px;">
                    <span id="bloom-value" style="font-size: 12px; width: 24px;">1.5</span>
                </div>
            </div>
        </div>

        <div class="settings-group">
            <label class="settings-label">Themes</label>
            <div class="preset-grid">
                <button class="preset-btn active" data-theme="default">Gource Dark</button>
                <button class="preset-btn" data-theme="light">Light</button>
                <button class="preset-btn" data-theme="midnight">Midnight</button>
                <button class="preset-btn" data-theme="hacker">Hacker</button>
            </div>
        </div>

        <div class="settings-group">
            <label class="settings-label">View</label>
            <div class="color-picker-row">
                <span class="color-picker-label">Camera Padding</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="range" id="padding-slider" min="1.0" max="2.0" step="0.1" value="1.1"
                        style="width: 80px;">
                    <span id="padding-value" style="font-size: 12px; width: 24px;">1.1</span>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // ==================== State ====================
        const state = {
            commits: [],
            authors: new Map(),
            currentCommitIndex: -1,
            isPlaying: false,
            playSpeed: 1,
            lastFrameTime: 0,
            timeSinceLastCommit: 0,
            visibleFiles: new Set(),
            totalLinesAdded: 0,
            totalLinesDeleted: 0
        };

        // ==================== Optimization (Spatial Hash) ====================
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.buckets = new Map();
            }

            clear() {
                this.buckets.clear();
            }

            getKey(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                return `${cx},${cy}`;
            }

            insert(node) {
                const key = this.getKey(node.position.x, node.position.y);
                if (!this.buckets.has(key)) {
                    this.buckets.set(key, []);
                }
                this.buckets.get(key).push(node);
            }

            getNearby(node) {
                const cx = Math.floor(node.position.x / this.cellSize);
                const cy = Math.floor(node.position.y / this.cellSize);
                const nearby = [];

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${cx + dx},${cy + dy}`;
                        if (this.buckets.has(key)) {
                            const bucket = this.buckets.get(key);
                            for (let i = 0; i < bucket.length; i++) {
                                nearby.push(bucket[i]);
                            }
                        }
                    }
                }
                return nearby;
            }
        }

        let spatialHash = new SpatialHash(150); // Cell size ~ 2 * FOLDER_DISTANCE

        // ==================== Three.js Setup ====================
        let scene, camera, renderer, controls;
        let composer, bloomPass;
        let treeGroup, authorGroup;
        let layoutNodes = new Map();
        let layoutEdges = [];
        let forceSimulationActive = false;
        let layoutAlpha = 1;
        let edgeLines = [];

        // Theme Config
        const themeConfig = {
            bgColor: '#0a0a12',
            dirColor: '#00d4ff',
            textColor: '#e8e8f0',
            cameraPadding: 1.1,
            bloomEnabled: true,
            bloomStrength: 1.5,
            extensionColors: true
        };

        // File Extension Colors Cache
        const extensionColorCache = new Map();

        function getExtensionColor(filename) {
            if (!themeConfig.extensionColors) return '#ffffff';

            const parts = filename.split('.');
            const ext = parts.length > 1 ? parts.pop().toLowerCase() : '';

            if (!ext) return '#aaaaaa'; // No extension

            if (extensionColorCache.has(ext)) {
                return extensionColorCache.get(ext);
            }

            // Generate vibrant color using Golden Ratio hash
            let hash = 0;
            for (let i = 0; i < ext.length; i++) {
                hash = ext.charCodeAt(i) + ((hash << 5) - hash);
            }

            // Gource style: map hash to hue, high saturation/lightness
            const hue = Math.abs(hash % 360);
            const color = `hsl(${hue}, 80%, 60%)`;

            extensionColorCache.set(ext, color);
            return color;
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(themeConfig.bgColor);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 800);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 150;   // Don't zoom in too close
            controls.maxDistance = 5000;  // Allow zooming out far enough to see all files
            controls.enableZoom = true;
            controls.zoomSpeed = 1.2;
            controls.enablePan = true;
            controls.screenSpacePanning = true;  // Better trackpad panning
            controls.touches = {          // Touch screen gestures
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            // Handle Mac trackpad pinch-to-zoom (wheel events with ctrlKey)
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };

            treeGroup = new THREE.Group();
            scene.add(treeGroup);
            authorGroup = new THREE.Group();
            scene.add(authorGroup);

            initParticleSystem();
            // Post-processing
            const renderScene = new RenderPass(scene, camera);

            const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
            bloomPass = new UnrealBloomPass(resolution, themeConfig.bloomStrength, 0.4, 0.85);
            bloomPass.enabled = themeConfig.bloomEnabled;

            const outputPass = new OutputPass();

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);

            // Resize handler
            window.addEventListener('resize', onWindowResize, false);
            state.lastFrameTime = performance.now();
            animate();
        }

        // Tooltip system
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let tooltipEl = null;
        let lastHoveredPath = null;  // For click-to-copy
        let lastHoveredAuthor = null;  // For click-to-copy author name

        function initTooltip() {
            tooltipEl = document.getElementById('tooltip');

            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseleave', hideTooltip);
            renderer.domElement.addEventListener('click', onCanvasClick);
        }

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check file nodes
            const fileMeshes = Array.from(layoutNodes.values())
                .filter(n => n.visible && n.isFile && n.mesh)
                .map(n => n.mesh);

            const fileIntersects = raycaster.intersectObjects(fileMeshes);

            if (fileIntersects.length > 0) {
                const path = fileIntersects[0].object.userData.path;
                showTooltip(path + ' (click to copy)', event.clientX, event.clientY);
                lastHoveredPath = path;
                renderer.domElement.style.cursor = 'pointer';
                return;
            }

            // Check author sprites
            const authorSprites = Array.from(state.authors.values())
                .filter(a => a.sprite && a.sprite.material.opacity > 0.1)
                .map(a => a.sprite);

            const authorIntersects = raycaster.intersectObjects(authorSprites);

            if (authorIntersects.length > 0) {
                // Find author by sprite
                for (const author of state.authors.values()) {
                    if (author.sprite === authorIntersects[0].object) {
                        showTooltip(author.name + ' (click to copy)', event.clientX, event.clientY);
                        lastHoveredAuthor = author.name;
                        lastHoveredPath = null;
                        renderer.domElement.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            lastHoveredPath = null;
            lastHoveredAuthor = null;
            renderer.domElement.style.cursor = 'default';
            hideTooltip();
        }

        function onCanvasClick(event) {
            const textToCopy = lastHoveredPath || lastHoveredAuthor;
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    tooltipEl.textContent = 'Copied!';
                    setTimeout(() => {
                        if (lastHoveredPath) {
                            tooltipEl.textContent = lastHoveredPath + ' (click to copy)';
                        } else if (lastHoveredAuthor) {
                            tooltipEl.textContent = lastHoveredAuthor + ' (click to copy)';
                        }
                    }, 1000);
                });
            }
        }

        function showTooltip(text, x, y) {
            tooltipEl.textContent = text;
            tooltipEl.classList.add('visible');
            tooltipEl.style.left = (x + 12) + 'px';
            tooltipEl.style.top = (y + 12) + 'px';
        }

        function hideTooltip() {
            tooltipEl.classList.remove('visible');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Camera auto-follow state
        let targetCameraZ = 800;
        let cameraFollowEnabled = true;

        function updateCameraFollow(deltaTime = 0.016) {
            if (!cameraFollowEnabled) return;

            const visibleNodes = Array.from(layoutNodes.values()).filter(n => n.visible);
            if (visibleNodes.length === 0) return;

            // Calculate bounding box
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (const node of visibleNodes) {
                minX = Math.min(minX, node.position.x);
                maxX = Math.max(maxX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxY = Math.max(maxY, node.position.y);
            }

            const width = maxX - minX + CAMERA_PADDING * 2 * themeConfig.cameraPadding;
            const height = maxY - minY + CAMERA_PADDING * 2 * themeConfig.cameraPadding;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            // Calculate required camera distance to fit content
            const fov = camera.fov * Math.PI / 180;
            const aspect = camera.aspect;
            const distForHeight = height / (2 * Math.tan(fov / 2));
            const distForWidth = width / (2 * Math.tan(fov / 2) * aspect);
            const requiredZ = Math.max(distForHeight, distForWidth, 300);

            targetCameraZ = requiredZ;

            // Improved Smooth camera movement (Time-based damping)
            const damping = 2.0; // Higher = faster
            const dt = Math.min(0.1, (performance.now() - state.lastFrameTime) / 1000); // reuse existing dt logic in animate ideally, but recomputing here for safety or pass it in
            const smoothFactor = 1 - Math.exp(-damping * dt); // or just use Three's damp

            // Using THREE.MathUtils.damp is cleaner if available, but doing manual exp decay is framework-agnostic-ish
            // standard lerp: current = current + (target - current) * factor
            // frame-independent lerp: factor = 1 - exp(-decay * dt)

            // We'll trust the animate loop to call this, but we need dt passed in. 
            // Refactoring updateCameraFollow to accept dt is better, but for now let's use fixed lerp or 
            // read global time. 
            // Actually, let's just make it better by using a properly tuned constant for now, 
            // or better yet, using the `deltaTime` available in `animate` if we pass it.
            // For minimal disruption, I will change `animate` to pass `deltaTime` to `updateCameraFollow`.
        }

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - state.lastFrameTime) / 1000;
            state.lastFrameTime = now;

            controls.update();

            if (forceSimulationActive) {
                updateForceLayout();
                updateEdgeLines();
            }

            if (state.isPlaying && state.commits.length > 0) {
                updatePlayback(deltaTime);
            }

            updateCameraFollow(deltaTime);
            updateParticles(deltaTime);
            updateAuthors(deltaTime);
            updateLaserBeams();

            composer.render();
        }

        // ==================== Particle System ====================
        const MAX_PARTICLES = 5000;
        let particlePositions, particleColors, particleVelocities, particleLifetimes, particleSizes;
        let particleGeometry, particleMaterial, particlePoints;

        function initParticleSystem() {
            particlePositions = new Float32Array(MAX_PARTICLES * 3);
            particleColors = new Float32Array(MAX_PARTICLES * 3);
            particleVelocities = [];
            particleLifetimes = new Float32Array(MAX_PARTICLES);
            particleSizes = new Float32Array(MAX_PARTICLES);

            for (let i = 0; i < MAX_PARTICLES; i++) {
                particleVelocities.push({ x: 0, y: 0, z: 0 });
                particleLifetimes[i] = 0;
            }

            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: `
          attribute float size;
          varying vec3 vColor;
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
                fragmentShader: `
          varying vec3 vColor;
          void main() {
            float r = length(gl_PointCoord - vec2(0.5));
            if (r > 0.5) discard;
            float alpha = smoothstep(0.5, 0.0, r);
            gl_FragColor = vec4(vColor, alpha);
          }
        `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particlePoints = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particlePoints);
        }

        function emitParticles(position, color, count = 20) {
            for (let i = 0; i < count; i++) {
                let idx = -1;
                for (let j = 0; j < MAX_PARTICLES; j++) {
                    if (particleLifetimes[j] <= 0) {
                        idx = j;
                        break;
                    }
                }
                if (idx === -1) return;

                const angle = Math.random() * Math.PI * 2;
                const speed = 20 + Math.random() * 40;

                particlePositions[idx * 3] = position.x + (Math.random() - 0.5) * 10;
                particlePositions[idx * 3 + 1] = position.y + (Math.random() - 0.5) * 10;
                particlePositions[idx * 3 + 2] = position.z;

                particleColors[idx * 3] = color.r;
                particleColors[idx * 3 + 1] = color.g;
                particleColors[idx * 3 + 2] = color.b;

                particleVelocities[idx] = {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed,
                    z: (Math.random() - 0.5) * speed * 0.5
                };

                particleLifetimes[idx] = 1.0;
                particleSizes[idx] = 4 + Math.random() * 4;
            }
        }

        function updateParticles(deltaTime) {
            for (let i = 0; i < MAX_PARTICLES; i++) {
                if (particleLifetimes[i] <= 0) continue;

                particlePositions[i * 3] += particleVelocities[i].x * deltaTime;
                particlePositions[i * 3 + 1] += particleVelocities[i].y * deltaTime;
                particlePositions[i * 3 + 2] += particleVelocities[i].z * deltaTime;

                particleVelocities[i].x *= 0.98;
                particleVelocities[i].y *= 0.98;
                particleVelocities[i].z *= 0.98;

                particleLifetimes[i] -= deltaTime * 0.8;
                particleSizes[i] *= 0.99;
            }

            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;
            particleGeometry.attributes.size.needsUpdate = true;
        }

        // ==================== Git Log Parser ====================
        function parseGitLog(content) {
            // Normalize line endings: CRLF ‚Üí LF, CR ‚Üí LF (Windows compatibility)
            const normalizedContent = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const lines = normalizedContent.split('\n');
            const commits = [];
            let currentCommit = null;

            for (const line of lines) {
                if (line.startsWith('COMMIT|')) {
                    // Save previous commit
                    if (currentCommit) {
                        commits.push(currentCommit);
                    }

                    // Parse new commit
                    const parts = line.split('|');
                    if (parts.length >= 6) {
                        currentCommit = {
                            sha: parts[1],
                            author: {
                                name: parts[2],
                                email: parts[3]
                            },
                            timestamp: new Date(parts[4]),
                            message: parts.slice(5).join('|'), // In case message contains |
                            files: []
                        };
                    }
                } else if (currentCommit && line.trim()) {
                    // Try numstat format first (e.g., "10\t5\tsrc/file.js" or "-\t-\tbinary.png")
                    const numstatMatch = line.match(/^(\d+|-)\t(\d+|-)\t(.+)$/);
                    const statusMatch = line.match(/^([AMDR])\t(.+)$/); // For --name-status format

                    if (numstatMatch) {
                        const added = numstatMatch[1] === '-' ? 0 : parseInt(numstatMatch[1], 10);
                        const deleted = numstatMatch[2] === '-' ? 0 : parseInt(numstatMatch[2], 10);
                        let path = numstatMatch[3];

                        // Handle renames: "old => new" or "prefix{old => new}suffix"
                        if (path.includes(' => ')) {
                            // Handle {old => new} pattern - can appear anywhere in path
                            // e.g., "{scripts/compute => compute}/file.py" -> "compute/file.py"
                            // e.g., "src/{old => new}.js" -> "src/new.js"
                            while (path.includes('{') && path.includes(' => ')) {
                                path = path.replace(/\{[^{}]* => ([^{}]*)\}/, '$1');
                            }
                            // Handle simple "old => new" pattern (full path rename)
                            if (path.includes(' => ')) {
                                path = path.split(' => ').pop();
                            }
                        }

                        // Infer status from line changes (heuristic)
                        let status = 'modified';
                        if (added > 0 && deleted === 0) {
                            status = 'added';  // Likely a new file
                        } else if (added === 0 && deleted > 0) {
                            status = 'deleted';  // Likely a deleted file
                        }

                        currentCommit.files.push({
                            path: path,
                            status: status,
                            linesAdded: added,
                            linesDeleted: deleted
                        });
                        continue;
                    }

                    // Fallback: try name-status format (e.g., "M\tsrc/file.js") for backward compatibility
                    const nameStatusMatch = line.match(/^([AMDRT])\d*\t(.+)$/);
                    if (nameStatusMatch) {
                        const statusMap = {
                            'A': 'added',
                            'M': 'modified',
                            'D': 'deleted',
                            'R': 'renamed',
                            'T': 'modified'
                        };
                        let path = nameStatusMatch[2];
                        // Handle renames (old\tnew) - take the new path
                        if (path.includes('\t')) {
                            path = path.split('\t').pop();
                        }

                        currentCommit.files.push({
                            path: path,
                            status: statusMap[nameStatusMatch[1]] || 'modified',
                            linesAdded: 0,
                            linesDeleted: 0
                        });
                    }
                }
            }

            // Don't forget the last commit
            if (currentCommit) {
                commits.push(currentCommit);
            }

            return commits;
        }

        function buildTreeFromCommits(commits) {
            const allPaths = new Set();

            for (const commit of commits) {
                for (const file of commit.files) {
                    allPaths.add(file.path);
                    // Also add parent directories
                    const parts = file.path.split('/');
                    for (let i = 1; i < parts.length; i++) {
                        allPaths.add(parts.slice(0, i).join('/'));
                    }
                }
            }

            const root = {
                path: '',
                name: 'root',
                isFile: false,
                children: new Map(),
                depth: 0
            };

            for (const path of allPaths) {
                const parts = path.split('/');
                let current = root;

                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const currentPath = parts.slice(0, i + 1).join('/');
                    const isFile = i === parts.length - 1 && !allPaths.has(currentPath + '/');

                    if (!current.children.has(part)) {
                        current.children.set(part, {
                            path: currentPath,
                            name: part,
                            isFile: !Array.from(allPaths).some(p => p.startsWith(currentPath + '/')),
                            children: new Map(),
                            depth: i + 1
                        });
                    }
                    current = current.children.get(part);
                }
            }

            return root;
        }

        function collectAuthors(commits) {
            const authors = new Map();
            const colors = [
                new THREE.Color(0x00d4ff),
                new THREE.Color(0x7b2dff),
                new THREE.Color(0xff6b9d),
                new THREE.Color(0x00ff88),
                new THREE.Color(0xffaa00),
                new THREE.Color(0xff3366),
                new THREE.Color(0x00ffcc),
                new THREE.Color(0xff8844),
            ];

            let colorIndex = 0;
            for (const commit of commits) {
                const email = commit.author.email;
                if (!authors.has(email)) {
                    authors.set(email, {
                        name: commit.author.name,
                        email,
                        color: colors[colorIndex % colors.length],
                        sprite: null,
                        position: new THREE.Vector3(0, 0, 50),
                        targetPosition: new THREE.Vector3(0, 0, 50),
                        lastActiveTime: 0
                    });
                    colorIndex++;
                }
            }

            return authors;
        }

        // ==================== Force-Directed Layout ====================
        // Layout constants
        const FOLDER_DISTANCE = 75;       // Distance between folders (reduced for tighter clustering)
        const FILE_CLUSTER_RADIUS = 20;   // Max distance of files from parent folder
        const CAMERA_PADDING = 150;       // Camera view padding

        // Parent map for quick lookup
        const parentMap = new Map();
        // Path compression: skip single-child empty folders
        const effectiveParentMap = new Map();  // path ‚Üí effective parent (skipping compressed)
        const skippedFolders = new Set();       // folders to skip (compress)

        function initForceLayout(tree) {
            layoutNodes.clear();
            layoutEdges = [];
            parentMap.clear();

            function addNode(node, parentPath = null) {
                // Give each node a random angle for initial spread
                const angle = Math.random() * Math.PI * 2;
                const radius = node.depth * 50 + Math.random() * 30;

                const nodeData = {
                    path: node.path,
                    name: node.name,
                    isFile: node.isFile,
                    depth: node.depth,
                    position: new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    ),
                    velocity: new THREE.Vector3(0, 0, 0),
                    mesh: null,
                    visible: false,
                    clusterAngle: Math.random() * Math.PI * 2, // For file clustering
                    clusterRadius: Math.random() * FILE_CLUSTER_RADIUS
                };

                if (node.path === '') {
                    nodeData.position.set(0, 0, 0);
                }

                layoutNodes.set(node.path, nodeData);

                if (parentPath !== null) {
                    parentMap.set(node.path, parentPath);
                    // Only add edges between folders (not files)
                    if (!node.isFile) {
                        layoutEdges.push({ source: parentPath, target: node.path });
                    }
                }

                if (node.children) {
                    for (const child of node.children.values()) {
                        addNode(child, node.path);
                    }
                }
            }

            addNode(tree);

            // Compute path compression after tree is built
            computePathCompression();

            layoutAlpha = 1;
            forceSimulationActive = true;
        }

        // Compute which folders should be compressed (skipped in visualization)
        // A folder is skipped if: it has exactly 1 child folder AND 0 direct files
        function computePathCompression() {
            effectiveParentMap.clear();
            skippedFolders.clear();

            // Step 1: Count children for each folder
            const childrenCount = new Map(); // folderPath ‚Üí { folders: n, files: n }
            for (const [path, node] of layoutNodes) {
                if (path === '') continue;
                const parent = parentMap.get(path);
                if (parent === undefined) continue;

                if (!childrenCount.has(parent)) {
                    childrenCount.set(parent, { folders: 0, files: 0 });
                }
                const counts = childrenCount.get(parent);
                if (node.isFile) {
                    counts.files++;
                } else {
                    counts.folders++;
                }
            }

            // Step 2: Mark folders to skip (single-child chains with no direct files)
            // Never skip root - it's the anchor of the tree
            for (const [folderPath, counts] of childrenCount) {
                if (folderPath === '') continue;
                if (counts.folders === 1 && counts.files === 0) {
                    skippedFolders.add(folderPath);
                }
            }

            // Step 3: Build effective parent map (skip compressed folders)
            for (const [path, node] of layoutNodes) {
                if (path === '') continue;
                let parent = parentMap.get(path);
                // Walk up until we find a non-skipped folder (or root)
                while (parent && skippedFolders.has(parent)) {
                    parent = parentMap.get(parent);
                }
                effectiveParentMap.set(path, parent !== undefined ? parent : '');
            }
        }

        function updateForceLayout() {
            // Minimum alpha floor to prevent complete freeze - overlapping nodes will slowly separate
            const effectiveAlpha = Math.max(layoutAlpha, 0.1);

            // Only non-skipped folders participate in force simulation
            const folders = Array.from(layoutNodes.values()).filter(n =>
                (n.visible || n.path === '') && !n.isFile && !skippedFolders.has(n.path)
            );
            const files = Array.from(layoutNodes.values()).filter(n => n.visible && n.isFile);

            if (folders.length < 1) return;

            // 1. Repulsion between folders (Spatial Hash Optimized)
            const repulsionStrength = 4000;

            // Rebuild spatial hash
            spatialHash.clear();
            for (const node of folders) {
                spatialHash.insert(node);
            }

            for (const nodeA of folders) {
                // Get nearby nodes from spatial hash
                const neighbors = spatialHash.getNearby(nodeA);

                for (const nodeB of neighbors) {
                    if (nodeA === nodeB) continue;

                    const delta = new THREE.Vector3().subVectors(nodeA.position, nodeB.position);
                    const distSq = delta.lengthSq();

                    // Optimization: Skip if too far (though spatial hash already limits this)
                    // or if too close (avoid division by zero)
                    if (distSq < 0.1) continue;

                    const dist = Math.sqrt(distSq);
                    const force = repulsionStrength / distSq;
                    const forceVec = delta.normalize().multiplyScalar(force * effectiveAlpha);

                    if (nodeA.path !== '') nodeA.velocity.add(forceVec);
                    // We don't do nodeB.sub(forceVec) here because nodeB will be processed as nodeA in its own turn
                    // Wait, if we iterate all pairs via spatial hash, we might double count if we are not careful.
                    // But getNearby returns a list. If we process A->B, we will also process B->A later.
                    // So we should only ADD velocity to A. 
                }
            }

            // 2. Spring force between folders (using effectiveParentMap for compressed paths)
            const springStrength = 0.15;
            const processedSprings = new Set();
            for (const folder of folders) {
                if (folder.path === '') continue;

                const effectiveParent = effectiveParentMap.get(folder.path);
                if (effectiveParent === undefined) continue;

                // Avoid duplicate springs
                const springKey = `${effectiveParent}|${folder.path}`;
                if (processedSprings.has(springKey)) continue;
                processedSprings.add(springKey);

                const source = layoutNodes.get(effectiveParent);
                if (!source) continue;
                if (!source.visible && source.path !== '') continue;

                const restLength = source.path === '' ? FOLDER_DISTANCE * 1.2 : FOLDER_DISTANCE;

                const delta = new THREE.Vector3().subVectors(folder.position, source.position);
                const dist = delta.length();
                const force = (dist - restLength) * springStrength;
                const forceVec = delta.normalize().multiplyScalar(force * effectiveAlpha);

                if (source.path !== '') source.velocity.add(forceVec);
                folder.velocity.sub(forceVec);
            }

            // 3. Angular spread for sibling folders (using effectiveParentMap)
            const siblingMap = new Map();
            for (const folder of folders) {
                if (folder.path === '') continue;
                const effectiveParent = effectiveParentMap.get(folder.path) ?? '';
                if (!siblingMap.has(effectiveParent)) {
                    siblingMap.set(effectiveParent, []);
                }
                siblingMap.get(effectiveParent).push(folder);
            }

            // Spread siblings in a fan pattern
            for (const [parentPath, siblings] of siblingMap) {
                if (siblings.length < 2) continue;
                const parent = layoutNodes.get(parentPath);
                if (!parent) continue;

                const angularRepulsion = 800;
                for (let i = 0; i < siblings.length; i++) {
                    for (let j = i + 1; j < siblings.length; j++) {
                        const nodeA = siblings[i];
                        const nodeB = siblings[j];
                        const delta = new THREE.Vector3().subVectors(nodeA.position, nodeB.position);
                        const dist = Math.max(delta.length(), 1);
                        const force = angularRepulsion / (dist * dist);
                        const forceVec = delta.normalize().multiplyScalar(force * effectiveAlpha);
                        nodeA.velocity.add(forceVec);
                        nodeB.velocity.sub(forceVec);
                    }
                }
            }

            // 4. Outward expansion force - pushes nodes away from center to fill space
            const centerExpansion = 80;
            for (const node of folders) {
                if (node.path === '') continue;
                const dist = node.position.length();
                if (dist > 1) {
                    // Stronger gradient: 1/dist gives tighter feel to connections
                    const expansionForce = centerExpansion / (dist + 10);
                    const outwardForce = node.position.clone().normalize()
                        .multiplyScalar(expansionForce * effectiveAlpha);
                    node.velocity.add(outwardForce);
                }
            }

            // 5. Apply velocity with damping for folders
            const damping = 0.7;
            for (const node of folders) {
                if (node.path === '') continue;
                node.velocity.multiplyScalar(damping);
                node.position.add(node.velocity);

                if (node.mesh) {
                    node.mesh.position.copy(node.position);
                }
            }

            // 6. Position files using gravity trap model (attract to center + repel each other)
            // Use effectiveParentMap to group files by their non-compressed parent
            const filesByParent = new Map();
            for (const file of files) {
                const parentPath = effectiveParentMap.get(file.path);
                if (!filesByParent.has(parentPath)) {
                    filesByParent.set(parentPath, []);
                }
                filesByParent.get(parentPath).push(file);
            }

            const maxFileDistance = FILE_CLUSTER_RADIUS * 2.5;  // Hard boundary

            for (const [parentPath, siblingFiles] of filesByParent) {
                const parent = parentPath !== undefined ? layoutNodes.get(parentPath) : null;
                if (!parent) continue;

                // Single file: center directly on parent (no physics needed)
                if (siblingFiles.length === 1) {
                    const file = siblingFiles[0];
                    file.position.x += (parent.position.x - file.position.x) * 0.3;
                    file.position.y += (parent.position.y - file.position.y) * 0.3;
                    if (file.mesh) file.mesh.position.copy(file.position);
                    continue;
                }

                // Multiple files: gravity trap model
                for (const file of siblingFiles) {
                    const toParent = new THREE.Vector3().subVectors(parent.position, file.position);
                    const distToParent = toParent.length();

                    // Hard boundary: force pull back if too far
                    if (distToParent > maxFileDistance) {
                        const pullBack = toParent.normalize().multiplyScalar((distToParent - maxFileDistance) * 0.5);
                        file.position.add(pullBack);
                    }

                    // 1. Attraction - proportional to distance (stronger when farther)
                    if (distToParent > 5) {
                        const attractForce = toParent.normalize().multiplyScalar(distToParent * 0.05);
                        file.velocity.add(attractForce);
                    }

                    // 2. Repulsion from sibling files (reduced strength)
                    for (const other of siblingFiles) {
                        if (file === other) continue;
                        const delta = new THREE.Vector3().subVectors(file.position, other.position);
                        const dist = Math.max(delta.length(), 3);  // Min dist 3 to avoid extreme forces
                        const repelForce = delta.normalize().multiplyScalar(20 / (dist * dist));
                        file.velocity.add(repelForce);
                    }

                    // 3. Apply with damping (no layoutAlpha dependency)
                    file.velocity.multiplyScalar(0.6);
                    file.position.add(file.velocity);

                    if (file.mesh) {
                        file.mesh.position.copy(file.position);
                    }
                }
            }

            if (layoutAlpha > 0.001) {
                layoutAlpha *= 0.98;
            }
        }

        // ==================== Visualization ====================
        // File type color mapping
        const FILE_TYPE_COLORS = {
            // Code files
            js: 0xf7df1e,      // JavaScript - yellow
            ts: 0x3178c6,      // TypeScript - blue
            jsx: 0x61dafb,     // React - cyan
            tsx: 0x61dafb,
            vue: 0x42b883,     // Vue - green
            py: 0x3776ab,      // Python - dark blue
            go: 0x00add8,      // Go - cyan blue
            rs: 0xdea584,      // Rust - orange
            java: 0xed8b00,    // Java - orange
            rb: 0xcc342d,      // Ruby - red
            php: 0x777bb4,     // PHP - purple
            c: 0x555555,       // C - gray
            cpp: 0xf34b7d,     // C++ - pink
            cs: 0x178600,      // C# - green
            swift: 0xfa7343,   // Swift - orange
            kt: 0x7f52ff,      // Kotlin - purple
            // Styles
            css: 0x264de4,     // CSS - blue
            scss: 0xc6538c,    // SCSS - pink
            less: 0x1d365d,    // Less - dark blue
            // Markup/Data
            html: 0xe34c26,    // HTML - orange red
            md: 0x083fa1,      // Markdown - blue
            json: 0x292929,    // JSON - dark gray
            yaml: 0xcb171e,    // YAML - red
            yml: 0xcb171e,
            xml: 0x0060ac,     // XML - blue
            // Other
            sh: 0x89e051,      // Shell - green
            default: 0x8888aa  // Default - gray
        };

        function getFileColor(path) {
            const ext = path.split('.').pop()?.toLowerCase();
            return FILE_TYPE_COLORS[ext] || FILE_TYPE_COLORS.default;
        }

        function createNodeMesh(node) {
            const isDir = !node.isFile;
            const size = isDir ? 8 : 4;
            // Use configured directory color or extension color
            let colorVal;
            if (isDir) {
                colorVal = themeConfig.dirColor;
            } else {
                colorVal = getExtensionColor(node.path);
            }
            const color = new THREE.Color(colorVal);

            const geometry = new THREE.CircleGeometry(size, isDir ? 32 : 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0 // Start invisible
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { isNode: true, path: node.path, isFile: node.isFile, isDir };

            return mesh;
        }

        function addFileToVisualization(path) {
            const node = layoutNodes.get(path);
            if (!node || node.visible) return;

            // Also add parent directories (skip compressed folders)
            const parts = path.split('/');
            for (let i = 0; i < parts.length; i++) {
                const parentPath = parts.slice(0, i).join('/');
                // Skip compressed folders - they don't get visibility or mesh
                if (skippedFolders.has(parentPath)) continue;

                const parentNode = layoutNodes.get(parentPath);
                if (parentNode && !parentNode.visible) {
                    parentNode.visible = true;
                    if (!parentNode.mesh) {
                        parentNode.mesh = createNodeMesh(parentNode);
                        parentNode.mesh.position.copy(parentNode.position);
                        treeGroup.add(parentNode.mesh);
                    }
                    animateNodeIn(parentNode.mesh);
                }
            }

            node.visible = true;
            if (!node.mesh) {
                node.mesh = createNodeMesh(node);
                node.mesh.position.copy(node.position);
                treeGroup.add(node.mesh);
            }
            animateNodeIn(node.mesh);

            state.visibleFiles.add(path);
            forceSimulationActive = true;
            layoutAlpha = Math.max(layoutAlpha, 0.5);
        }

        function removeFileFromVisualization(path) {
            const node = layoutNodes.get(path);
            if (!node || !node.visible) return;

            node.visible = false;
            if (node.mesh) {
                animateNodeOut(node.mesh, () => {
                    treeGroup.remove(node.mesh);
                    node.mesh = null;
                });
            }

            state.visibleFiles.delete(path);
        }

        function animateNodeIn(mesh) {
            // Hide folder nodes - only show files
            const isDir = mesh.userData.isDir;
            if (isDir) {
                mesh.material.opacity = 0;
                mesh.scale.setScalar(0);
                return;
            }

            mesh.scale.setScalar(0.1);
            mesh.material.opacity = 0;

            const startTime = performance.now();
            const duration = 300;

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3);

                mesh.scale.setScalar(0.1 + eased * 0.9);
                mesh.material.opacity = eased * 1.0;

                if (t < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function animateNodeOut(mesh, onComplete) {
            const startTime = performance.now();
            const duration = 200;

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1);

                mesh.scale.setScalar(1 - t * 0.9);
                mesh.material.opacity = (1 - t) * 1.0;

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    onComplete();
                }
            }
            animate();
        }

        function updateEdgeLines() {
            // 1. Find folders to render (walk up effectiveParentMap from visible files)
            const foldersToRender = new Set();
            const files = Array.from(layoutNodes.values()).filter(n => n.visible && n.isFile);

            for (const file of files) {
                // Walk up the effective parent chain (skips compressed folders)
                let current = effectiveParentMap.get(file.path);
                while (current !== undefined && current !== '') {
                    foldersToRender.add(current);
                    current = effectiveParentMap.get(current);
                }
            }
            foldersToRender.add(''); // root always included

            // 2. Clean up old lines
            for (const line of edgeLines) {
                treeGroup.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }
            edgeLines = [];

            // 3. Draw edges: from each folder to its effectiveParent
            for (const folderPath of foldersToRender) {
                if (folderPath === '') continue;

                const node = layoutNodes.get(folderPath);
                if (!node || !node.visible) continue;

                const effectiveParent = effectiveParentMap.get(folderPath);
                if (effectiveParent === undefined) continue;

                const source = layoutNodes.get(effectiveParent);
                if (!source) continue;
                if (!source.visible && effectiveParent !== '') continue;

                const geometry = new THREE.BufferGeometry().setFromPoints([
                    source.position,
                    node.position
                ]);
                const material = new THREE.LineBasicMaterial({
                    color: 0x6080b0,
                    transparent: true,
                    opacity: 1.0
                });
                const line = new THREE.Line(geometry, material);
                treeGroup.add(line);
                edgeLines.push(line);
            }
        }

        // ==================== Laser Beams (Triangle) ====================
        let laserBeams = [];

        function createLaserBeam(author, targetNode, isDelete = false) {
            // Create triangle: apex at author, base at target
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(9); // 3 vertices * 3 coordinates
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex([0, 1, 2]);

            // Muted color with low opacity (red tint for delete)
            const material = new THREE.MeshBasicMaterial({
                color: isDelete ? 0xff4444 : author.color,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = {
                author: author,
                targetNode: isDelete ? null : targetNode,
                // For delete: store fixed position since node will disappear
                fixedTargetPos: isDelete ? targetNode.position.clone() : null,
                startTime: performance.now(),
                duration: 500
            };

            scene.add(mesh);
            laserBeams.push(mesh);
        }

        function updateLaserBeams() {
            const now = performance.now();

            for (let i = laserBeams.length - 1; i >= 0; i--) {
                const beam = laserBeams[i];
                const elapsed = now - beam.userData.startTime;
                const t = elapsed / beam.userData.duration;

                if (t >= 1) {
                    scene.remove(beam);
                    beam.geometry.dispose();
                    beam.material.dispose();
                    laserBeams.splice(i, 1);
                } else {
                    beam.material.opacity = 0.25 * (1 - t);

                    // Update triangle vertices
                    const authorPos = beam.userData.author.position;
                    // Use fixed position for delete lasers, otherwise track node position
                    const targetPos = beam.userData.fixedTargetPos || beam.userData.targetNode.position;

                    // Direction and perpendicular for base width
                    const dir = new THREE.Vector3().subVectors(targetPos, authorPos);
                    const length = dir.length();
                    const baseWidth = Math.min(length * 0.12, 15); // Triangle base width

                    // Perpendicular vector in XY plane
                    const perp = new THREE.Vector3(-dir.y, dir.x, 0).normalize().multiplyScalar(baseWidth);

                    const positions = beam.geometry.attributes.position.array;
                    // Apex (author position)
                    positions[0] = authorPos.x;
                    positions[1] = authorPos.y;
                    positions[2] = authorPos.z;
                    // Base left
                    positions[3] = targetPos.x + perp.x;
                    positions[4] = targetPos.y + perp.y;
                    positions[5] = targetPos.z;
                    // Base right
                    positions[6] = targetPos.x - perp.x;
                    positions[7] = targetPos.y - perp.y;
                    positions[8] = targetPos.z;

                    beam.geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        // ==================== Author Sprites ====================
        function createAuthorSprite(author) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const centerX = 64;
            const centerY = 64;

            const r = Math.floor(author.color.r * 255);
            const g = Math.floor(author.color.g * 255);
            const b = Math.floor(author.color.b * 255);

            // Draw outer glow (smaller, more subtle)
            const glowLayers = [
                { radius: 48, alpha: 0.03 },
                { radius: 42, alpha: 0.08 },
                { radius: 36, alpha: 0.12 }
            ];

            for (const layer of glowLayers) {
                const gradient = ctx.createRadialGradient(centerX, centerY, layer.radius * 0.5, centerX, centerY, layer.radius);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${layer.alpha})`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, layer.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw main circle (radius reduced by 1/5: 28 * 0.8 = 22)
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 22, 0, Math.PI * 2);
            ctx.fill();

            // Draw white border (width doubled: 2 -> 4)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 22, 0, Math.PI * 2);
            ctx.stroke();

            // Draw initial letter
            ctx.fillStyle = '#000';
            ctx.font = 'bold 26px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(author.name[0].toUpperCase(), centerX, centerY);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0,
                depthWrite: false  // Prevent transparent areas from blocking other objects
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.setScalar(53);  // 35 * 1.5

            return sprite;
        }

        // Median helper function (resistant to outliers)
        function median(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        function showAuthorForFiles(author, files) {
            // Use camera distance for relative positioning (adapts to view scale)
            const spawnRadius = camera.position.z * 0.08;  // ~8% of view width
            const wanderDist = spawnRadius * 0.3;

            // Create sprite on first appearance
            if (!author.sprite) {
                author.sprite = createAuthorSprite(author);
                // Initial position near first file
                const firstFile = files[0];
                const outwardDir = new THREE.Vector3(firstFile.position.x, firstFile.position.y, 0).normalize();
                if (outwardDir.length() < 0.1) {
                    const angle = Math.random() * Math.PI * 2;
                    outwardDir.set(Math.cos(angle), Math.sin(angle), 0);
                }
                author.position.set(
                    firstFile.position.x + outwardDir.x * spawnRadius,
                    firstFile.position.y + outwardDir.y * spawnRadius,
                    20
                );
                author.sprite.position.copy(author.position);
                authorGroup.add(author.sprite);
            }

            // Create laser for each file
            for (const file of files) {
                createLaserBeam(author, file);
            }

            // Calculate center using median (resistant to outliers)
            const xs = files.map(f => f.position.x);
            const ys = files.map(f => f.position.y);
            const centerX = median(xs);
            const centerY = median(ys);

            // Target position: center outer side + small wander
            const outwardDir = new THREE.Vector3(centerX, centerY, 0).normalize();
            if (outwardDir.length() < 0.1) {
                const angle = Math.random() * Math.PI * 2;
                outwardDir.set(Math.cos(angle), Math.sin(angle), 0);
            }

            const newTargetX = centerX + outwardDir.x * spawnRadius;
            const newTargetY = centerY + outwardDir.y * spawnRadius;

            // Only move if distance change is significant (reduce jitter)
            const currentDist = Math.hypot(
                author.targetPosition.x - newTargetX,
                author.targetPosition.y - newTargetY
            );

            if (currentDist > spawnRadius * 0.5) {
                const wanderAngle = Math.random() * Math.PI * 2;
                author.targetPosition.set(
                    newTargetX + Math.cos(wanderAngle) * wanderDist,
                    newTargetY + Math.sin(wanderAngle) * wanderDist,
                    20
                );
            }

            author.sprite.material.opacity = 1;
            author.lastActiveTime = performance.now() / 1000;
        }

        function updateAuthors(deltaTime) {
            const fadeStartDelay = 3 / state.playSpeed;  // Start fading after inactivity
            const fadeSpeed = 0.4 * state.playSpeed;
            const now = performance.now() / 1000;

            // Calculate scale factor to keep contributor sprites at fixed viewport size
            const baseSize = 53;  // 35 * 1.5
            const baseDistance = 800;  // Reference camera distance
            const cameraZ = camera.position.z;
            const scaleFactor = cameraZ / baseDistance;

            for (const author of state.authors.values()) {
                if (!author.sprite) continue;

                const timeSinceActive = now - author.lastActiveTime;

                // Move toward target (deceleration with relative max speed)
                const delta = new THREE.Vector3().subVectors(author.targetPosition, author.position);
                const dist = delta.length();
                if (dist > 0.5) {
                    const decelFactor = 1 - Math.pow(0.02, deltaTime * state.playSpeed);
                    const moveAmount = dist * decelFactor;
                    const maxSpeed = cameraZ * 0.3 * deltaTime;  // Relative to view, independent of playSpeed
                    const actualMove = Math.min(moveAmount, maxSpeed);
                    author.position.add(delta.normalize().multiplyScalar(actualMove));
                    author.sprite.position.copy(author.position);
                }

                // Fade out after inactivity
                if (timeSinceActive > fadeStartDelay) {
                    author.sprite.material.opacity -= fadeSpeed * deltaTime;
                    if (author.sprite.material.opacity < 0) {
                        author.sprite.material.opacity = 0;
                    }
                }

                // Keep contributor sprite at fixed viewport size (scales with camera distance)
                author.sprite.scale.setScalar(baseSize * scaleFactor);
            }
        }

        // ==================== Playback ====================
        function updatePlayback(deltaTime) {
            state.timeSinceLastCommit += deltaTime * state.playSpeed;

            const commitDuration = 0.5;

            if (state.timeSinceLastCommit >= commitDuration) {
                state.timeSinceLastCommit = 0;

                // Find next commit with file changes (skip empty commits)
                let nextIndex = state.currentCommitIndex + 1;
                while (nextIndex < state.commits.length && state.commits[nextIndex].files.length === 0) {
                    nextIndex++;
                }

                if (nextIndex >= state.commits.length) {
                    state.currentCommitIndex = state.commits.length - 1;
                    state.isPlaying = false;
                    document.getElementById('play-btn').textContent = '‚ñ∂';
                    return;
                }

                state.currentCommitIndex = nextIndex;
                processCommit(state.commits[state.currentCommitIndex]);
                updateUI();
            }
        }

        function processCommit(commit) {
            const avatarEl = document.getElementById('author-avatar');
            avatarEl.textContent = commit.author.name[0].toUpperCase();
            avatarEl.style.background = '';

            const author = state.authors.get(commit.author.email);
            if (author) {
                const color = author.color;
                avatarEl.style.background = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;
            }

            document.getElementById('author-name').textContent = commit.author.name;
            document.getElementById('commit-message').textContent = commit.message;

            const filesEl = document.getElementById('commit-files');
            filesEl.innerHTML = '';
            const maxFiles = 5;
            const files = commit.files.slice(0, maxFiles);

            // Calculate commit totals
            let commitAdded = 0;
            let commitDeleted = 0;
            for (const file of commit.files) {
                commitAdded += file.linesAdded || 0;
                commitDeleted += file.linesDeleted || 0;
            }

            for (const file of files) {
                const div = document.createElement('div');
                div.className = `file-change ${file.status}`;

                const fileName = document.createElement('span');
                fileName.textContent = file.path.split('/').pop();
                div.appendChild(fileName);

                // Only show line stats if we have actual data (not from old name-status format)
                if (file.linesAdded > 0 || file.linesDeleted > 0) {
                    const stats = document.createElement('span');
                    stats.className = 'line-stats';
                    const parts = [];
                    if (file.linesAdded > 0) parts.push(`<span class="added">+${file.linesAdded}</span>`);
                    if (file.linesDeleted > 0) parts.push(`<span class="deleted">-${file.linesDeleted}</span>`);
                    stats.innerHTML = parts.join(' ');
                    div.appendChild(stats);
                }

                filesEl.appendChild(div);
            }
            if (commit.files.length > maxFiles) {
                const div = document.createElement('div');
                div.className = 'file-change';
                div.textContent = `+${commit.files.length - maxFiles} more`;
                div.style.opacity = '0.6';
                filesEl.appendChild(div);
            }

            // Add commit summary (only show non-zero values)
            if (commitAdded > 0 || commitDeleted > 0) {
                const summary = document.createElement('div');
                summary.className = 'commit-line-summary';
                const parts = [];
                if (commitAdded > 0) parts.push(`<span class="added">+${commitAdded}</span>`);
                if (commitDeleted > 0) parts.push(`<span class="deleted">-${commitDeleted}</span>`);
                summary.innerHTML = parts.join(' ');
                filesEl.appendChild(summary);
            }

            // Update cumulative totals (only during playback, jumpToCommit recalculates)
            state.totalLinesAdded += commitAdded;
            state.totalLinesDeleted += commitDeleted;
            document.getElementById('stat-lines-added').textContent = state.totalLinesAdded.toLocaleString();
            document.getElementById('stat-lines-deleted').textContent = state.totalLinesDeleted.toLocaleString();

            const activeFiles = [];  // Collect active file nodes for author positioning

            for (const file of commit.files) {
                const node = layoutNodes.get(file.path);
                if (!node) continue;

                if (file.status === 'added' || file.status === 'modified' || file.status === 'renamed') {
                    addFileToVisualization(file.path);
                    if (node.visible && node.isFile) {
                        activeFiles.push(node);
                    }
                } else if (file.status === 'deleted') {
                    // Create delete laser before removing (need node position)
                    if (author && node.visible) {
                        createLaserBeam(author, node, true);  // true = delete laser (fixed position)
                    }
                    removeFileFromVisualization(file.path);
                }
            }

            // Update author position once based on all files (using median for outlier resistance)
            if (author && activeFiles.length > 0) {
                showAuthorForFiles(author, activeFiles);
            }
        }

        function updateUI() {
            const commit = state.commits[state.currentCommitIndex];
            if (!commit) return;

            document.getElementById('timeline-date').textContent = commit.timestamp.toLocaleDateString();
            document.getElementById('timeline-commit').textContent =
                `Commit ${state.currentCommitIndex + 1} / ${state.commits.length}`;

            const slider = document.getElementById('timeline-slider');
            slider.max = state.commits.length - 1;
            slider.value = state.currentCommitIndex;

            document.getElementById('stat-commits').textContent = `${state.currentCommitIndex + 1} / ${state.commits.length}`;
            document.getElementById('stat-files').textContent = state.visibleFiles.size;
            document.getElementById('stat-lines-added').textContent = state.totalLinesAdded.toLocaleString();
            document.getElementById('stat-lines-deleted').textContent = state.totalLinesDeleted.toLocaleString();
        }

        function jumpToCommit(index) {
            for (const node of layoutNodes.values()) {
                if (node.mesh) {
                    treeGroup.remove(node.mesh);
                    node.mesh = null;
                }
                node.visible = false;
            }
            state.visibleFiles.clear();

            for (const line of edgeLines) {
                treeGroup.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }
            edgeLines = [];

            for (let i = 0; i <= index; i++) {
                const commit = state.commits[i];
                for (const file of commit.files) {
                    if (file.status === 'added' || file.status === 'modified' || file.status === 'renamed') {
                        const node = layoutNodes.get(file.path);
                        if (node) {
                            // Set parent folders visible (skip compressed folders)
                            const parts = file.path.split('/');
                            for (let j = 0; j < parts.length; j++) {
                                const parentPath = parts.slice(0, j).join('/');
                                if (skippedFolders.has(parentPath)) continue;
                                const parentNode = layoutNodes.get(parentPath);
                                if (parentNode) parentNode.visible = true;
                            }
                            node.visible = true;
                            state.visibleFiles.add(file.path);
                        }
                    } else if (file.status === 'deleted') {
                        const node = layoutNodes.get(file.path);
                        if (node) {
                            node.visible = false;
                            state.visibleFiles.delete(file.path);
                        }
                    }
                }
            }

            // Create meshes for visible nodes (skip compressed folders)
            for (const node of layoutNodes.values()) {
                if (node.visible && !node.mesh) {
                    // Only create mesh for files and non-skipped folders
                    if (node.isFile || !skippedFolders.has(node.path)) {
                        node.mesh = createNodeMesh(node);
                        node.mesh.position.copy(node.position);
                        // Only show files, hide folder nodes
                        if (node.isFile) {
                            node.mesh.material.opacity = 1.0;
                        } else {
                            node.mesh.material.opacity = 0;
                            node.mesh.scale.setScalar(0);
                        }
                        treeGroup.add(node.mesh);
                    }
                }
            }

            updateEdgeLines();
            forceSimulationActive = true;
            layoutAlpha = 0.5;

            // Recalculate cumulative line stats up to (but not including) this commit
            // processCommit will add the current commit's stats
            state.totalLinesAdded = 0;
            state.totalLinesDeleted = 0;
            for (let i = 0; i < index; i++) {
                for (const file of state.commits[i].files) {
                    state.totalLinesAdded += file.linesAdded || 0;
                    state.totalLinesDeleted += file.linesDeleted || 0;
                }
            }

            state.currentCommitIndex = index;
            state.timeSinceLastCommit = 0;
            updateUI();

            if (state.commits[index]) {
                processCommit(state.commits[index]);
            }
        }

        // ==================== File Loading ====================
        function loadFile(file) {
            showLoading('Reading file...');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    processFileContent(content);
                } catch (error) {
                    hideLoading();
                    showError('Failed to parse file: ' + error.message);
                }
            };
            reader.onerror = () => {
                hideLoading();
                showError('Failed to read file');
            };
            reader.readAsText(file);
        }

        function processFileContent(content) {
            showLoading('Parsing git history...');
            setProgress(20);

            setTimeout(() => {
                const commits = parseGitLog(content);

                if (commits.length === 0) {
                    hideLoading();
                    showError('No commits found. Make sure you used the correct git command.');
                    return;
                }

                setProgress(50);
                showLoading(`Found ${commits.length} commits...`);

                state.commits = commits;
                const tree = buildTreeFromCommits(commits);
                state.authors = collectAuthors(commits);

                setProgress(70);
                showLoading('Building visualization...');

                initForceLayout(tree);

                document.getElementById('stat-commits').textContent = state.commits.length;
                document.getElementById('stat-authors').textContent = state.authors.size;

                setProgress(100);

                setTimeout(() => {
                    document.getElementById('intro-screen').classList.add('hidden');
                    document.getElementById('stats-panel').style.display = 'block';
                    document.getElementById('commit-panel').style.display = 'block';
                    document.getElementById('control-panel').style.display = 'block';
                    document.getElementById('reset-btn').style.display = 'block';

                    hideLoading();

                    if (state.commits.length > 0) {
                        state.currentCommitIndex = -1;
                        jumpToCommit(0);
                    }
                }, 300);
            }, 100);
        }

        // ==================== UI Helpers ====================
        function showLoading(text) {
            const overlay = document.getElementById('loading-overlay');
            overlay.classList.remove('hidden');
            document.getElementById('loading-text').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        function setProgress(percent) {
            document.getElementById('progress-fill').style.width = `${percent}%`;
        }

        function showError(message) {
            const toast = document.getElementById('error-toast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 5000);
        }

        // ==================== Event Listeners ====================
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');

        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadFile(e.target.files[0]);
            }
        });

        // Copy command
        document.getElementById('command-text').addEventListener('click', async () => {
            const command = document.getElementById('command-text').textContent;
            try {
                await navigator.clipboard.writeText(command);
                const feedback = document.getElementById('copy-feedback');
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 1500);
            } catch (e) {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = command;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
            }
        });

        // Play button
        document.getElementById('play-btn').addEventListener('click', () => {
            if (state.commits.length === 0) return;

            state.isPlaying = !state.isPlaying;
            document.getElementById('play-btn').textContent = state.isPlaying ? '‚è∏' : '‚ñ∂';

            if (state.isPlaying) {
                state.lastFrameTime = performance.now();
                state.timeSinceLastCommit = 0;
            }

            if (state.currentCommitIndex >= state.commits.length - 1 && state.isPlaying) {
                jumpToCommit(0);
            }
        });

        // Timeline slider
        document.getElementById('timeline-slider').addEventListener('input', (e) => {
            const index = parseInt(e.target.value);
            state.isPlaying = false;
            document.getElementById('play-btn').textContent = '‚ñ∂';
            jumpToCommit(index);
        });

        // Speed buttons
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.playSpeed = parseFloat(btn.dataset.speed);
            });
        });

        // Reset button
        document.getElementById('reset-btn').addEventListener('click', () => {
            location.reload();
        });

        // ==================== Settings & Themes ====================
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const settingsOverlay = document.getElementById('settings-overlay');
        const closeSettings = document.getElementById('close-settings');

        function toggleSettings() {
            const isVisible = settingsModal.classList.contains('visible');
            if (isVisible) {
                settingsModal.classList.remove('visible');
                settingsOverlay.classList.remove('visible');
            } else {
                settingsModal.classList.add('visible');
                settingsOverlay.classList.add('visible');
            }
        }

        settingsBtn.addEventListener('click', toggleSettings);
        closeSettings.addEventListener('click', toggleSettings);
        settingsOverlay.addEventListener('click', toggleSettings);

        // Color Inputs
        const bgColorPicker = document.getElementById('bg-color-picker');
        const dirColorPicker = document.getElementById('dir-color-picker');
        const textColorPicker = document.getElementById('text-color-picker');

        function updateThemeColors() {
            // Update CSS variables
            document.documentElement.style.setProperty('--theme-bg', themeConfig.bgColor);
            document.documentElement.style.setProperty('--theme-text', themeConfig.textColor);
            document.documentElement.style.setProperty('--theme-dir', themeConfig.dirColor);

            // Update Three.js
            if (scene) {
                scene.background = new THREE.Color(themeConfig.bgColor);
            }

            // Update existing directory nodes
            const dirColor = new THREE.Color(themeConfig.dirColor);
            for (const node of layoutNodes.values()) {
                if (!node.isFile && node.mesh) {
                    node.mesh.material.color.copy(dirColor);
                }
            }
        }

        bgColorPicker.addEventListener('input', (e) => {
            themeConfig.bgColor = e.target.value;
            updateThemeColors();
        });

        dirColorPicker.addEventListener('input', (e) => {
            themeConfig.dirColor = e.target.value;
            updateThemeColors();
        });

        textColorPicker.addEventListener('input', (e) => {
            themeConfig.textColor = e.target.value;
            updateThemeColors();
        });

        // Padding Slider
        const paddingSlider = document.getElementById('padding-slider');
        const paddingValue = document.getElementById('padding-value');

        paddingSlider.addEventListener('input', (e) => {
            themeConfig.cameraPadding = parseFloat(e.target.value);
            paddingValue.textContent = themeConfig.cameraPadding;
        });

        // Bloom Settings
        const bloomToggle = document.getElementById('bloom-toggle');
        const bloomSlider = document.getElementById('bloom-slider');
        const bloomValue = document.getElementById('bloom-value');

        bloomToggle.addEventListener('change', (e) => {
            themeConfig.bloomEnabled = e.target.checked;
            if (bloomPass) bloomPass.enabled = themeConfig.bloomEnabled;
        });

        bloomSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            themeConfig.bloomStrength = val;
            bloomValue.textContent = val;
            if (bloomPass) bloomPass.strength = val;
        });

        // Extension Colors Toggle
        const extColorsToggle = document.getElementById('ext-colors-toggle');

        extColorsToggle.addEventListener('change', (e) => {
            themeConfig.extensionColors = e.target.checked;

            // Re-colorize existing file nodes
            for (const node of layoutNodes.values()) {
                if (node.isFile && node.mesh) {
                    const newColor = new THREE.Color(getExtensionColor(node.path));
                    node.mesh.material.color.copy(newColor);
                }
            }
        });

        // Themes
        const themes = {
            default: { bg: '#0a0a12', text: '#e8e8f0', dir: '#00d4ff' },
            light: { bg: '#ffffff', text: '#333333', dir: '#007aff' },
            midnight: { bg: '#000000', text: '#cccccc', dir: '#ff00ff' },
            hacker: { bg: '#0d1117', text: '#00ff00', dir: '#00ff00' }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const themeName = btn.dataset.theme;
                const theme = themes[themeName];
                if (theme) {
                    themeConfig.bgColor = theme.bg;
                    themeConfig.textColor = theme.text;
                    themeConfig.dirColor = theme.dir;

                    bgColorPicker.value = theme.bg;
                    textColorPicker.value = theme.text;
                    dirColorPicker.value = theme.dir;

                    updateThemeColors();
                }
            });
        });

        // ==================== Initialize ====================
        initThree();

    </script>
    <script defer
        src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015"
        integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ=="
        data-cf-beacon='{"version":"2024.11.0","token":"d659a3e253184c21ba8ef71050e2280a","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}'
        crossorigin="anonymous"></script>
</body>

</html>